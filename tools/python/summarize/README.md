summarize
=========

Scripts for summarizing results.

The entry point is `main.py`.
It accepts three different data formats.
- `./main.py FILE.rktd` takes the output from our `run.rkt` script, creates a copy `FILE.tab`, then produces exact figures and statistics about the tab file.
- `./main.py FILE.tab` produces exact figures and statistics about the `.tab` file.
- `./main.py DIR` accepts a properly-formatted experiment directory and does simple random sampling to guess the performance costs of gradual typing.

__Important__: calling `main.py` with a directory instead of data yields non-deterministic results.
Given a directory, it assumes running all configurations is not feasible and instead does random sampling.

Additionally, the script implicitly depends on a file `FILE.graph` that describes the dependency structure of modules represented in the data.
The module graph is inferred from the input.

Pre-Requisites
--------------
Nearly everything here is implemented in Python.
Use [easy_install](http://peak.telecommunity.com/DevCenter/EasyInstall) and/or [pip](https://pypi.python.org/pypi/pip) to get the Python dependencies.

- [Racket](http://www.racket-lang.org)
- [Python 3](https://www.python.org/downloads/) (will probably work with Python 2.7)
- [matplotlib](http://matplotlib.org/downloads.html)
- [networkx](https://networkx.github.io/download.html)
- [numpy](http://www.numpy.org/)
- [SciPy](http://www.scipy.org/)
- [pandas](http://pandas.pydata.org/)
- [statmodels](http://statsmodels.sourceforge.net/)

As a heads up, we'll probably add these dependencies in the future:
- [seaborn](http://stanford.edu/~mwaskom/software/seaborn/)

### FAQ

###### Cannot import `add_newdocs` (raised from Numpy's `__init__.py`)
- __Observed__: when trying to install `SciPy 0.15.1` using `pip 6.1.1`.
- __Solution__: remove `SciPy` and `numpy`, reinstall through `easy_install`.

###### `numpy.dtype` has wrong size, try recompiling
- __Observed__: when trying to install `statsmodels` using `pip 6.1.1` after building `numpy 1.9.2` from source
- __Solution__: rebuild `numpy` and `scipy` and `pandas` using `easy_install`. Today's lesson was `easy_install > pip`.


Basic Usage + Assumptions
-------------------------
### Background
The purpose of these scripts is to learn from raw data collected on gradual typing.

The run script (`run.rkt` in this repository) takes a project folder as input and runs all gradually-typed configurations a specified number of times.
It saves the results of each run into a 2-dimensional vector.
The first dimension is the configuration (aka, the set of typed modules) and the second is a particular run of that configuration.

### Usage
Our main script will produce summary results on any `.rktd` file generated by the run script.
Alternatively, it accepts a project directory and will call the run script itself to generate some (but not all) data.

The script implicitly relies on a module graph file matching the specification below.
If the input data is titled `foo.rktd`, the module graph must be called `foo.rktd` and stored in the same directory tree as either the current directory or the `foo.rktd` file (we do some searching for you, but not much).
The exception to this naming convention are hyphen characters; each of `foo.rktd`, `foo-2.rktd`, and `foo-april-1.rktd` will infer the module graph `foo.graph`.


### Supported Data Formats
#### .rktd
Output from the `run.rkt` script is by definition valid input.

#### .tab
Because outputs from `run.rkt` are not very readable, our `main.py` generates a `.tab` file representing the same dataset.
Given `file.rktd`, we generate `file.tab` with contents like:
```
Run	1	2	3
00	88	89	88
01	121	212	150
10	177	121	221
11	3	3	3
```
The first row indexes the experiment runs (this row may be completely ignored).
All other rows name a configuration and list the experimental data for each run of that configuration.

#### directory
Given a project folder that matches the assumptions made by `run.rkt`, we simulate the results of running a full experiment via simple random sampling.

##### Expected Structure
Input directories must have three sub-folders:
- `base/`
- `typed/`
- `untyped/`
The `base/` folder should contain Racket files and supporting data that is shared across typed/untyped configurations.
The `typed/` folder should be a Typed Racket implementation of the benchmark.
The `untyped/` folder should be an (untyped) Racket implementation of the benchmark.
None of these folders may contain sub-folders.
The `typed/` and `untyped/` folders must have the same number of files and these files must have the same names.

Optionally, the directory may contain a `both/` folder for files that should be pasted in to each typed/untyped configuration.

The name of the folder is inferred to be the name of the benchmark.
This name is used to find a module graph file in the current directory.

##### Sampling
Instead of running all configuration, our script samples running times of a few randomly-selected configurations.
We stratify the set of all configurations based on the the number of typed modules and sample from each of those sets, summarizing all the samples in a graph.

Sampling may later be expanded with other measures and output formats.


### Module Graphs
To make interesting pictures, we require a `.graph` file representing each project.
This is a tab-separated file naming the modules in the project, their position in configuration strings, and their dependencies.

For example, suppose we have a project with three files and the following dependence graph, shown in ASCII:
```
A.rkt <--- B.rkt <--- C.rkt
```
So `A.rkt` does not have any requires, `B.rkt` requires `A.rkt` and is required by `C.rkt`, and `C.rkt` requires `B.rkt`.
Suppose also that the configuration bitstring `100` means that only `A.rkt` is typed and that `001` means that only `C.rkt` is typed.
The `.graph` file for this project must say exactly the following:
```
MODULE	INDEX	REQUIRES
A.rkt	0	
B.rkt	1	A.rkt
C.rkt	2	B.rkt
```
If these files have other requires to files outside the experiment, do _not_ include them in the `.graph` file.

A `.graph` file for the current project must be located in the current directory (where the `main.py` script is invoked) or some sub-directory.
As mentioned above, we infer the name of a graph file by taking the input `FILE.rktd` and stripping everything to the right of the left-most period (`.`) or hyphen (`-`) character, whichever comes first.

Output
------
Running `main.py file.rktd` generates a `.tex` file and a few pictures.
Running with a directory generates a `.tex` file with fewer pictures.

#### TeX
The generated `.tex` file comes in four basic "parts".
- The first page is the most useful.
  It names the project & its modules, and maps the natural number bitstring index to each module.
  It also gives statistics for the untyped, typed, and gradually-typed running times.
- Next are a few pictures summarizing the first page.
  - The normalized runtimes describe how adding types affect the baseline (untyped) performance.
    The bar for "Top 3" shows the least slowdown gradully-typed configurations give.
    The bar for "Bottom 3" shows the greatest slowdown observed on any combination of typed modules.
  - The next image, a violin plot, is useful for seeing the distribution of all gradually-typed configurations.
    That's all it's good for, and we will replace it soon with something more tailored to that job.
  - The third image shows the distribution of running times for all configurations with `N` typed modules (for some fixed `N`).
    This shows how bad things can get after adding types to some part of the project.
- The next four sections detail the best and worst gradually-typed configurations.
  These are the same configurations shown in the "normalized runtimes" bar graph.
  Only now, we get a detailed view of the typed modules and the boundaries in the configuration.
- Last is a family of violin plots comparing the running times when each module is fixed as either typed, or untyped.
  Look for no overlap between different-colored violins.
  (We will replace this picture with a scatterplot or joint distribution. The violin plots were fast, but aren't useful.)

#### Pictures
- `file_normalized-runtimes-bar.png` is a bar graph of a few running times normalized to the average untyped runtime.
  These running times are for:
  - untyped : the fully-untyped configuration
  - gradually typed : the average over all gradually typed configurations
  - top gradual : the average of the most performant 10 (or 10%) gradually-typed configurations
  - bot gradual : the average of the worst (highest overhead) few gradually-typed configurations
  - typed : the fully-typed configuration
- `file_untyped-vs-gradual-vs-typed-violin.png` shows three violin plots side-by-side.
  These plots show the distribution of the fully untyped runtimes, all gradually typed running times, and the fully-typed runtimes.
  (In retrospect, fully-untyped and fully-typed are often poor violins. We only see the variation in our measurements.)
- `file_by-typed-modules-violin.png` stratifies gradually typed configurations by the number of typed modules and shows a violin plot for each.
- `file_module-graph*.png` shows a module graph for one configuration.
(Of these pictures, only `file_by-typed-modules-violin.png` is simulated when `main.py` is called with a directory.)
  Nodes corresponding to untyped modules are colored differently from nodes corresponding to typed modules, and edges (aka, requires) across a typed/untyped boundary are highlighted red.

File Summary
------------
Names and brief descriptions of other files in this folder.

### Classes
The code defines two important classes.

#### AbstractSummary
An `AbstractSummary` represents an experiment.
In practice, an instance is either a `TabfileSummary` representing the ground truth data obtained from a `.rktd` or `.tab` file
or a `SrsSummary` representing a project folder we can run queries on using simple random sampling.

The main feature of these objects is that we can `render` them to get a printed summary of results.
Soon we'll probably also have ways to make smaller, focused queries.

#### ModuleGraph
A `ModuleGraph` object encapsulates the module dependence graph of a project.
These are created from `.graph` files and contain.
- The set of module names
- A mapping from configuration bitstring indices to module names
- The set of modules required by any one module.


### Scripts

#### config.py
Utilities for working with configuration bitstrings.
These tools understand that strings like "0101" really mean "exactly two modules in this configuration are typed".

#### constants.py
Project-wide constants; for example, location to save output pictures.

#### main.py
Entry point to the project.

#### plot.py
Wrapper for `matplotlib`.
Functions for creating bar, box, violin, and module plots.

#### latex.py
Simple bindings for outputting valid LaTeX.

#### shell.py
Wrapper to Python's subprocess library.
Useful for running and getting output from shell commands.

#### sexp-to-tab.rkt
Convert the output of `run.rkt` to a more-readable `.tab` file.

#### util.py
Simple utility functions, mostly for working with files.

